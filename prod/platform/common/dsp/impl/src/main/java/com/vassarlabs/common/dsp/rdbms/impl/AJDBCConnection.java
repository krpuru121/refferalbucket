package com.vassarlabs.common.dsp.rdbms.impl;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.UUID;

import com.vassarlabs.common.dsp.context.DataStoreContext;
import com.vassarlabs.common.dsp.err.DSPException;
import com.vassarlabs.common.dsp.rdbms.api.IJDBCConnection;
import com.vassarlabs.common.utils.StringUtils;
import com.vassarlabs.common.utils.err.BugInCodeErrorObject;

public abstract class AJDBCConnection
	implements IJDBCConnection {
	
	protected String ctxTransactionId = null;

	@Override
	public boolean releaseConnection(String connectionOwnerKey)
		throws DSPException {
		
		// If Transaction is in progress then do not close connection, throw error
		// else close connection
		if (StringUtils.isNullOrEmpty(ctxTransactionId)
			&& !DataStoreContext.isTransactionInProgress()) {
			closeConnection(connectionOwnerKey);
			return true;
		} else {
			// TODO: Log error
			Thread.dumpStack();
			throw new DSPException(new BugInCodeErrorObject("Bug in code, Trying to close connection while transaction is active : TID=" + Thread.currentThread().getName() + ":" + Thread.currentThread().getId()));
		}
	}

	@Override
	public String beginTransaction()
		throws DSPException {

		if (DataStoreContext.isTransactionInProgress()) {
			return null;
		}
			
		String transactionId = null;
		try {
			getConnection().setAutoCommit(false);
			transactionId = UUID.randomUUID().toString();
			DataStoreContext.setTransactionInProgress();
			ctxTransactionId = transactionId;
			return transactionId;
		} catch (SQLException se) {
			// TODO: Log Error
			throw new DSPException("Error beginning transaction", se);
		}
	}

	@Override
	public boolean commitTransaction(String transactionId)
		throws DSPException {

		if (!DataStoreContext.isTransactionInProgress()) {
			return false;
		}
	
		if (!StringUtils.isNullOrEmpty(ctxTransactionId)
			&& ctxTransactionId.equals(transactionId)) {
			commit();
			ctxTransactionId = null;
			return true;
		}
		return false;
	}

	@Override
	public boolean rollbackTransaction(String transactionId)
		throws DSPException {

		if (!DataStoreContext.isTransactionInProgress()) {
			return false;
		}
	
		if (!StringUtils.isNullOrEmpty(ctxTransactionId)
			&& ctxTransactionId.equals(transactionId)) {
			rollback();
			ctxTransactionId = null;
			return true;
		}
		return false;
	}

	protected abstract Connection getConnection()
		throws DSPException;
	
	protected abstract boolean closeConnection(String connectionOwnerKey)
		throws DSPException;

	protected abstract boolean commit()
		throws DSPException;
	
	protected abstract boolean rollback()
		throws DSPException;
		
	public PreparedStatement createPreparedStatement(String sql)
		throws SQLException {
		
		try {
			return getConnection().prepareStatement(sql);
		} catch (SQLException e) {
			// TODO: Log error
			throw new SQLException("Error creating prepared statement for sql=" + sql, e);
		} catch (DSPException e) {
			// TODO: Log error
			throw new SQLException("Error creating prepared statement for sql=" + sql, e);
		}
	}
	
	public PreparedStatement createPreparedStatement(String sql, int autoGeneratedKeys)
		throws SQLException {

		try {
			return getConnection().prepareStatement(sql, autoGeneratedKeys);
		} catch (SQLException e) {
			// TODO : Log error
			throw new SQLException("Error creating prepared statement for sql=" + sql + " - with autoGeneratedKeys=" + autoGeneratedKeys, e);
		} catch (DSPException e) {
			// TODO : Log error
			throw new SQLException("Error creating prepared statement for sql=" + sql + " - with autoGeneratedKeys=" + autoGeneratedKeys, e);
		}
	}
	
	public PreparedStatement createPreparedStatement(String sql, int resultSetType, int resultSetConcurrency)
		throws SQLException {

		try {
			return getConnection().prepareStatement(sql, resultSetType, resultSetConcurrency);
		} catch (SQLException e) {
			// TODO : Log error
			throw new SQLException("Error creating prepared statement for sql=" + sql + " - with resultSetType=" + resultSetType + " and resultSetConcurrency=" + resultSetConcurrency, e);
		} catch (DSPException e) {
			// TODO : Log error
			throw new SQLException("Error creating prepared statement for sql=" + sql + " - with resultSetType=" + resultSetType + " and resultSetConcurrency=" + resultSetConcurrency, e);
		}
	}
	
	public Statement createStatement(int resultSetType, int resultSetConcurrency)
		throws SQLException {
		
		try {
			return getConnection().createStatement(resultSetType, resultSetConcurrency);
		} catch (SQLException e) {
			// TODO: Log Error
			throw e;
		} catch (DSPException e) {
			// TODO: Log Error
			throw new SQLException("Error creating Statement for resultSetType="+resultSetType + " resultSetConcurrency=" + resultSetConcurrency, e);
		}
	}
	
	public CallableStatement createCallableStatement(String sql) throws SQLException {
		try {
			return getConnection().prepareCall(sql);
		} catch (SQLException e) {
			throw e;
		} catch (DSPException e) {
			throw new SQLException("Error preparing callable statement for " + sql);
		}
	}
}

